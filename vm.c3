module vm;

import std::collections::map;
import std::collections::list;

import std::io;
import common;
import raylib;
import animation;

distinct InstructionIndex = usz;

enum InstructionType : char {
    SHOW_TEXT,
    GOTO_LABEL,
    END_SCENARIO,

    CHARACTER_VISIBILITY_SET,
    CHARACTER_POSITION,
    CHARACTER_EMOTE,
    CHARACTER_FACE,

    BACKGROUND,

    ANIMATE,
}

struct Instruction {
    InstructionType instruction_type;

    bool blocking;

    InstructionIndex previous_instruction_pointer;

    union {
        /* SHOW_TEXT */
        struct {
            char[] text_to_show;
            char[] previously_shown_text;
        }

        /* GOTO_LABEL */
        union {
            InstructionIndex label_to_go_to;
            usz              scene_index;
        }

        struct {
            CharacterIndex character_index;

            union {
                /* CHARACTER_VISIBILITY_SET */
                struct {
                    bool   set_visibility_to;
                    bool   previous_visibility;
                }

                /* CHARACTER_POSITION */
                struct {
                    Vector2 set_position_to;
                    Vector2 previous_position;
                }

                /* CHARACTER_EMOTE */
                struct {
                    char[] set_emotion_to;
                    char[] previous_emotion;
                }

                /* CHARACTER_FACE */
                struct {
                    Direction direction_to_face;
                    Direction previous_direction;
                }
            }
        }

        /* ANIMATE */
        struct {
            AnimationIndex animation_index;
            AnimationIndex previous_animation_index;
        }

        /* BACKGROUND */
        struct {
            SpriteDataIndex background_index;
            SpriteDataIndex previous_background_index;
        }

        /* END_SCENARIO */
        // nothing needed
    }
}


InstructionIndex    instruction_pointer;
List(<Instruction>) instructions;
List(<Instruction>) instruction_history;

fn bool last_instruction_blocking() {
    if(instruction_history.size < 2) return true; // fix case where starting from non blocking instruction lets you rewind too far
    return instruction_history[instruction_history.size - 1].blocking;
}

fn bool step() {
    Instruction inst = instructions[(usz)instruction_pointer];
    InstructionIndex old_instruction_pointer = instruction_pointer;

    bool no_push = false;

    switch(inst.instruction_type) {
    case InstructionType.SHOW_TEXT:
        inst.previously_shown_text = common::text.text;
        common::text.text = inst.text_to_show;
        common::text.step = 0;
        instruction_pointer += 1;
    case InstructionType.GOTO_LABEL:
        instruction_pointer = inst.label_to_go_to;
    case InstructionType.CHARACTER_VISIBILITY_SET:
        inst.previous_visibility = common::characters[inst.character_index].visible;
        (&common::characters[inst.character_index]).visible = inst.set_visibility_to;

        instruction_pointer += 1;
    case InstructionType.CHARACTER_POSITION:
        inst.previous_position = common::characters[inst.character_index].position;
        (&common::characters[inst.character_index]).position = inst.set_position_to;

        instruction_pointer += 1;
    case InstructionType.CHARACTER_EMOTE:
        inst.previous_emotion = common::characters[inst.character_index].current_emotion;
        (&common::characters[inst.character_index]).current_emotion = inst.set_emotion_to;

        instruction_pointer += 1;
    case InstructionType.ANIMATE:
        inst.previous_animation_index = common::current_animation;
        common::current_animation     = inst.animation_index;

        (&animation::animation_list[inst.animation_index]).reset();

        instruction_pointer += 1;
    case InstructionType.BACKGROUND:
        inst.previous_background_index = common::current_background;
        common::current_background     = inst.background_index;

        instruction_pointer += 1;
    case InstructionType.CHARACTER_FACE:
        inst.previous_direction = common::characters[inst.character_index].direction;
        (&common::characters[inst.character_index]).direction = inst.direction_to_face;

        instruction_pointer += 1;
    case InstructionType.END_SCENARIO:
        inst.previously_shown_text = common::text.text;
        common::text.text = "END.";
        common::text.step = 0;
        no_push = (instruction_history[^1].instruction_type == InstructionType.END_SCENARIO);
    }
    inst.previous_instruction_pointer = old_instruction_pointer;
    if(!no_push) instruction_history.push(inst);
    return inst.blocking;
}

fn void step_back() {
    if(instruction_history.size < 2) return;

    Instruction inst = instruction_history.pop()!!;

    switch(inst.instruction_type) {
    case InstructionType.SHOW_TEXT:
    case InstructionType.END_SCENARIO:
        common::text.text = inst.previously_shown_text;

    case InstructionType.ANIMATE:
        (&animation::animation_list[inst.animation_index]).reset();
        animation::animation_list[inst.animation_index].apply();

        common::current_animation = inst.previous_animation_index;

        (&animation::animation_list[common::current_animation]).reset();

    case InstructionType.BACKGROUND:
        common::current_background = inst.previous_background_index;

    case InstructionType.CHARACTER_VISIBILITY_SET: (&common::characters[inst.character_index]).visible         = inst.previous_visibility;
    case InstructionType.CHARACTER_POSITION:       (&common::characters[inst.character_index]).position        = inst.previous_position;
    case InstructionType.CHARACTER_EMOTE:          (&common::characters[inst.character_index]).current_emotion = inst.previous_emotion;
    case InstructionType.CHARACTER_FACE:           (&common::characters[inst.character_index]).direction       = inst.previous_direction;
    case InstructionType.GOTO_LABEL:               break;
    }
    instruction_pointer = inst.previous_instruction_pointer;
}
